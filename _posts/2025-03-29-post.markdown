---
layout: post
title:  "Minesweeper (1)"
date:   2025-03-29 08:28:19 +0100
categories: rust 
---

So, minesweeper, interview problem at my job.
The problem is given as follows:

```
Minesweeper C/C++ exercise
1. Generate a NxN Minesweeper-Board with B bombs positioned randomly.
   The parameters N and B are passed as command line arguments.
   N and B are positive integers, B is less than NxN.
  
2. For each position, display the number of bombs in the neighborhood.

Limited Time: 60 minutes.
Clarity and readability of the code will be evaluated first, correctness second.

Example:
$ ./minesweeper 5 2
board:
.*...
..*..
.....
.....
.....

neighbors:
1*21.
12*1.
.111.
.....
.....
```
My first version is [here](https://github.com/Julien5/sandbox/blob/ae61a93e049e00a3115cbebe63aea0640fe2a147/test/rust/minesweeper/src/main.rs). (It took me much more than one hour to do that). Nothing very exciting about this exercise, but if you think of (very) large grids, it can get interesting. 

## Generating the bombs

The first idea that comes to mind is the generate random numbers until we have $$B$$ distinct numbers, like this
{% highlight rust %}
		let mut rng = StdRng::from_os_rng();
		let B=10;
		let N=10;
		let mut set=std::collections::HashSet::new();
		while set.len() != B {
			set.insert(rng.random_range(0..N*N));
		}
{% endhighlight %}
It most cases it works. This could be problematic if there are many bombs (think of the extreme case $$B=N^2$$), but if $$ B>\frac{N^2}{2} $$ we can invert the logic and generate bomb-free positions instead of bomb positions. Privileging [time](https://en.wikipedia.org/wiki/Time_complexity) over [space](https://en.wikipedia.org/wiki/Space_complexity) complexity, I choose the [FisherYates shuffle](https://en.wikipedia.org/wiki/Fisher%E2%80%93Yates_shuffle) which make $$B$$ *distincts* random numbers out of any $$B$$ random numbers, distincts or not. It has $$O(N^2)$$ space complexity (memory requirement). 







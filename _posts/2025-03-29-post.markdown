---
layout: post
title:  "Minesweeper (1)"
date:   2025-03-29 08:28:19 +0100
categories: rust 
---

So, minesweeper, interview problem at my job.
The problem is given as follows:

```
Minesweeper C/C++ exercise
1. Generate a NxN Minesweeper-Board with B bombs positioned randomly.
   The parameters N and B are passed as command line arguments.
   N and B are positive integers, B is less than NxN.
  
2. For each position, display the number of bombs in the neighborhood.

Limited Time: 60 minutes.
Clarity and readability of the code will be evaluated first, correctness second.

Example:
$ ./minesweeper 5 2
board:
.*...
..*..
.....
.....
.....

neighbors:
1*21.
12*1.
.111.
.....
.....
```
Nothing very exciting about this exercise. My first version is [here](https://github.com/Julien5/sandbox/blob/ae61a93e049e00a3115cbebe63aea0640fe2a147/test/rust/minesweeper/src/main.rs). (It took me much more than one hour to do that) The minesweeper board is implemented with a vector of size $$ N=n^2 $$. 
{% highlight rust %}
	let N = n*n;
	let mut grid : Vec<usize> = vec![ZERO; N];
	let Bx = distinct_random_numbers(N,b);
	for p in &Bx {
		grid[*p]=BOMB;
	}
{% endhighlight %}

Generating random bomb positions is easy. Generating *distinct* random bomb positions is a bit more involved, but there is a trick called `shuffle`:
{% highlight rust %}
fn distinct_random_numbers(N:usize,b:usize) -> Vec<usize> {
	let mut G : Vec<usize>=(0usize..N).collect();
	let mut rng = rng();
	// shuffle it and keep the first b elements.
	G.shuffle(&mut rng);
	G.truncate(b);
	G
}
{% endhighlight %}

For printing, i did not stick to the 
{% highlight rust %}
fn print_grid(grid:&[usize]) {
	let print_lookup: [char;11] = [' ','1','2','3','4','5','6','7','8','B',' '];
	// ...
	for k1 in 0..n {
		for k2 in 0..n {
			let k=from_2d((k1,k2),n);
			print!("| {} ",print_lookup[grid[k]]);
		}
		println!("|");
	}
}
{% endhighlight %}
